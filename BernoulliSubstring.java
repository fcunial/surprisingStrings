/**
 * A substring that can compute the exact expectation and variance of the number of its
 * occurrences in a string generated by a given IID source, as well as scores of
 * statistical surprise, using its longest border. See \cite{apostolico2000efficient} for
 * algorithms, and \cite{apostolico2003monotony} for statistics.
 */
public class BernoulliSubstring extends BorderSubstring {
	/**
	 * $\log_{e}(\bar{p})$, where $\bar{p} = \prod_{i=0}^{|v|-1}\mathbb{P}(v[i])$.
	 */
	protected double logBarP;

	/**
	 * $f(v) = \sum_{b \in borders(v)}(|s|-2|v|+b+1)\prod_{i=b}^{|v|-1}\mathbb{P}(v[i])$,
	 * where $s$ is the text and $borders(v)$ is the set of all border lengths of $v$.
	 */
	protected double f;

	/**
	 * $g(v) = \sum_{b \in borders(v)}\prod_{i=b}^{|v|-1}\mathbb{P}(v[i])$
	 */
	protected double g;

	protected double expectation, variance;

	/**
	 * Temporary scratch space, allocated at most once.
	 */
	private BernoulliSubstring tmpString;


	/**
	 * Artificial no-argument constructor, used just to avoid compile-time errors.
	 * See the no-argument constructor of $Substring$ for details.
	 */
	protected BernoulliSubstring() { }


	public BernoulliSubstring(int alphabetLength, int log2alphabetLength, long bwtLength, int log2bwtLength) {
		super(alphabetLength,log2alphabetLength,bwtLength,log2bwtLength);
	}


	protected Substring getInstance() {
		return new BernoulliSubstring(alphabetLength,log2alphabetLength,bwtLength,log2bwtLength);
	}


	protected final void pushHeadPrime(Stream stack) {
		super.pushHeadPrime(stack);
		stack.push(Double.doubleToLongBits(logBarP),64);
		if (rightLength>0) {
			stack.push(Double.doubleToLongBits(f),64);
			stack.push(Double.doubleToLongBits(g),64);
		}
	}


	protected void readHeadPrime(Stream stack, boolean fast) {
		super.readHeadPrime(stack,fast);
		logBarP=Double.longBitsToDouble(stack.read(64));
		if (rightLength>0) {
			if (fast && hasBeenExtended) {
				f=-1;
				g=-1;
				stack.setPosition(stack.getPosition()+64*2);
			}
			else {
				f=Double.longBitsToDouble(stack.read(64));
				g=Double.longBitsToDouble(stack.read(64));
			}
		}
	}


	protected void popHeadPrime(Stream stack) {
		stack.pop(rightLength>0?64*3:64);
		super.popHeadPrime(stack);
	}


	/**
	 * Remark: the recursive computations in this method hold only for
	 * $length<=HALF_TEXT_LENGTH$.
	 */
	protected void init(Substring suffix, int firstCharacter, Stream stack, RigidStream characterStack, SimpleStream pointerStack, long[] buffer) {
		super.init(suffix,firstCharacter,stack,characterStack,pointerStack,buffer);
		if (firstCharacter==-1) return;
		final double barP, x, longestBorderG;
		final long backupPointer, longestBorderLength;
		expectation=0;
		variance=0;

		// Expectation and first term of the variance
		logBarP=((BernoulliSubstring)suffix).logBarP+Constants.logProbabilities[firstCharacter];
		barP=Math.exp(logBarP);
		expectation=(bwtLength-length)*barP;
		variance+=barP*(1-barP);

		// Second term of the variance
		variance-=(barP*barP)*(((bwtLength-1)<<1)-3*length+2)*(length-1);

		// $f(v)$ and $g(v)$
		if (rightLength>0) {
			longestBorderLength=longestBorder.length;
			if (tmpString==null) tmpString=(BernoulliSubstring)getInstance();  // Executed only once
			backupPointer=stack.getPosition();
			stack.setPosition(pointerStack.getElementAt(length-longestBorderLength-1));
			tmpString.read(stack,true,true);
			stack.setPosition(backupPointer);
			x=Math.exp(tmpString.logBarP);
			longestBorderG=((BernoulliSubstring)longestBorder).g;
			f = x*( bwtLength-(length<<1)+longestBorderLength +
			        ((BernoulliSubstring)longestBorder).f-((length-longestBorderLength)<<1)*longestBorderG );
			g = x*(1+longestBorderG);
			variance+=2*barP*f;
		}

		// Right-extensions of $v$
		// ...
	}

}



	/**
	 * Loads also $logBarP$
	 */
/*	protected void skip(Stream stack) {
		super.skip(stack);
		logBarP=Double.longBitsToDouble(stack.read(64));
		stack.setPosition(stack.getPosition()+64*2);
	}
*/


/**
	 * TRUE=use a tighter upper bound for the Poisson error in method
	 * $getCumulativeProbability$.
	 */
//	private static final boolean TIGHT_POISSON_ERROR = true;

	/**
	 * Computes the probability that the number of occurrences $occ$ of $v$ in an IID text
	 * of length $TEXT_LENGTH$ is less than or equal to $observedOccurrences$.
	 *
	 * Remark: this method uses some potentially slow procedures in the Apache Commons
	 * Math library to compute cumulative probabilities for normal and Poisson
	 * distribution.
	 *
	 * @return $out[0]=\mathbb{P}[occ \leq observedOccurrences]$; $out[1]$: upper bound on
	 * the absolute error in cell 0 when the Poisson distribution is used to model $occ$.
	 */
/*	public final void getCumulativeProbability(int observedOccurrences, double[] out) {
		final int SIGNIFICANTLY_GREATER_THAN = 100;
		final double pHat, pHatSquare, shortestPeriod;
		final double probability;
		double poissonError = 0;

		shortestPeriod=length-longestBorderLength;
		pHat=Math.exp(pHatLog);
		pHatSquare=pHat*pHat;
		if (shortestPeriod/length>SIGNIFICANTLY_GREATER_THAN*ONE_OVER_LOG_TEXT_LENGTH && TEXT_LENGTH>SIGNIFICANTLY_GREATER_THAN*length) {
			// Using Poisson distribution with mean equal to $expectation$.
			// b1=pHatSquare*(-3*length*length+(length<<2)+((length*TEXT_LENGTH)<<1)-TEXT_LENGTH-1);
			// b2=b1+variance-expectation;
			poissonError=variance-expectation+StrictMath.scalb(pHatSquare,1)*(-3*length*length+(length<<2)+((length*TEXT_LENGTH)<<1)-TEXT_LENGTH-1);
			if (TIGHT_POISSON_ERROR) poissonError*=-Math.expm1(0d-expectation)/expectation;
			probability=(new PoissonDistribution(expectation)).cumulativeProbability(observedOccurrences);
		}
		else probability=(new NormalDistribution(expectation,Math.sqrt(variance))).cumulativeProbability(observedOccurrences);
		out[0]=probability; out[1]=poissonError;
	}

*/

