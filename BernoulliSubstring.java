import org.apache.commons.math3.distribution.PoissonDistribution;
import org.apache.commons.math3.distribution.NormalDistribution;

/**
 * A substring that can compute the exact expectation and variance of the number of its
 * occurrences in a string generated by a given IID source, as well as scores of
 * statistical surprise, using its longest border. See \cite{apostolico2000efficient} for
 * algorithms, and \cite{apostolico2003monotony} for statistics.
 */
public class BernoulliSubstring extends BorderSubstring {
	/**
	 * $\log_{e}(\bar{p})$, where $\bar{p} = \prod_{i=0}^{|v|-1}\mathbb{P}(v[i])$.
	 */
	protected double logBarP;

	/**
	 * $f(v) = \sum_{b \in borders(v)}(|s|-2|v|+b+1)\prod_{i=b}^{|v|-1}\mathbb{P}(v[i])$,
	 * where $s$ is the text and $borders(v)$ is the set of all border lengths of $v$.
	 */
	protected double f;

	/**
	 * $g(v) = \sum_{b \in borders(v)}\prod_{i=b}^{|v|-1}\mathbb{P}(v[i])$
	 */
	protected double g;

	protected double expectation, variance, pValue, pValueError;

	/**
	 * Temporary scratch space, allocated at most once.
	 */
	private BernoulliSubstring tmpString;


	/**
	 * Artificial no-argument constructor, used just to avoid compile-time errors.
	 * See the no-argument constructor of $Substring$ for details.
	 */
	protected BernoulliSubstring() { }


	public BernoulliSubstring(int alphabetLength, int log2alphabetLength, long bwtLength, int log2bwtLength) {
		super(alphabetLength,log2alphabetLength,bwtLength,log2bwtLength);
	}


	protected void deallocate() {
		super.deallocate();
		if (tmpString!=null) {
			tmpString.deallocate();
			tmpString=null;
		}
	}


	protected Substring getInstance() {
		return new BernoulliSubstring(alphabetLength,log2alphabetLength,bwtLength,log2bwtLength);
	}


	protected final void pushHeadPrime(Stream stack) {
		super.pushHeadPrime(stack);
		stack.push(Double.doubleToLongBits(logBarP),64);
		if (rightLength>0) {
			stack.push(Double.doubleToLongBits(f),64);
			stack.push(Double.doubleToLongBits(g),64);
		}
	}


	protected void readHeadPrime(Stream stack, boolean fast) {
		super.readHeadPrime(stack,fast);
		logBarP=Double.longBitsToDouble(stack.read(64));
		if (rightLength>0) {
			if (fast && hasBeenExtended) {
				f=-1;
				g=-1;
				stack.setPosition(stack.getPosition()+64*2);
			}
			else {
				f=Double.longBitsToDouble(stack.read(64));
				g=Double.longBitsToDouble(stack.read(64));
			}
		}
	}


	protected void popHeadPrime(Stream stack) {
		stack.pop(rightLength>0?64*3:64);
		super.popHeadPrime(stack);
	}


	/**
	 * Remark: the recursive computations in this method hold only for
	 * $length<=HALF_TEXT_LENGTH$.
	 */
	protected void init(Substring suffix, int firstCharacter, Stream stack, RigidStream characterStack, SimpleStream pointerStack, long[] buffer) {
		super.init(suffix,firstCharacter,stack,characterStack,pointerStack,buffer);
		if (firstCharacter==-1) return;
		final double barP, barPSquare, x, longestBorderG, b1, b2;
		long backupPointer, longestBorderLength;
		expectation=0;
		variance=0;

		// Expectation and first term of the variance
		logBarP=((BernoulliSubstring)suffix).logBarP+Constants.logProbabilities[firstCharacter];
		barP=Math.exp(logBarP);
		barPSquare=barP*barP;
		expectation=(bwtLength-length)*barP;
		variance+=barP*(1-barP);

		// Second term of the variance
		variance-=barPSquare*(((bwtLength-1)<<1)-3*length+2)*(length-1);

		// $f(v)$ and $g(v)$
		longestBorderLength=0;
		if (rightLength>0) {
			longestBorderLength=longestBorder.length;
			if (tmpString==null) tmpString=(BernoulliSubstring)getInstance();  // Executed only once
			backupPointer=stack.getPosition();
			stack.setPosition(pointerStack.getElementAt(length-longestBorderLength-1));
			tmpString.read(stack,true,true);
			stack.setPosition(backupPointer);
			x=Math.exp(tmpString.logBarP);
			longestBorderG=((BernoulliSubstring)longestBorder).g;
			f = x*( bwtLength-(length<<1)+longestBorderLength +
			        ((BernoulliSubstring)longestBorder).f-((length-longestBorderLength)<<1)*longestBorderG );
			g = x*(1+longestBorderG);
			variance+=2*barP*f;
		}

		// Probability of observing $frequency()$ or more occurrences of $v$ in a random
		// string. Uses the Chen-Stein method: see Section 6 of \cite{apostolico2000efficient}.
		f=frequency();
		if (f<=Integer.MAX_VALUE && (length-longestBorderLength)/(double)length>Constants.GG*oneOverLogTextLength && textLength>Constants.GG*length) {
			b1 = barPSquare*( ((length*textLength)<<1) - textLength -3*length*length + (length<<2) - 1);
			b2 = variance-expectation+b1;
			pValueError=b1+b2;
			if (Constants.TIGHT_POISSON_ERROR) pValueError*=-Math.expm1(0D-expectation)/expectation;
			pValue=1D-(new PoissonDistribution(expectation)).cumulativeProbability((int)f);
		}
		else if (variance>0) {
			pValue=1D-(new NormalDistribution(expectation,Math.sqrt(variance))).cumulativeProbability(f);
			pValueError=-1;
		}
		else {
			pValue=-1;
			pValueError=-1;
		}

		// Right-extensions of $v$
		// ...
	}

}